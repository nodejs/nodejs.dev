---
title: 'v8'
displayTitle: 'V8'
category: 'api'
editPage: 'https://github.com/nodejs/node/blob/v18.8.0/doc/api/v8.md'
version: 'v18'
---

<Metadata version="v18.8.0" data={{"update":{"type":"introduced_in","version":["v4.0.0"]}}} />

<Metadata version="v18.8.0" data={{"source_link":"lib/v8.js"}} />

Le module `node:v8` expose les APIs qui sont spécifiques à la version de [V8][]
intégrée dans le binaire de Node.js. On peut y accéder en utilisant :

```js
const v8 = require('node:v8');
```

### <DataTag tag="M" /> `v8.cachedDataVersionTag()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

* Returns: [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Renvoie un nombre entier représentant une étiquette de version dérivée de la version V8,
des drapeaux de la ligne de commande, et des caractéristiques détectées du CPU. Ceci est utile pour déterminer
si un tampon [`vm.Script`][] `cachedData` est compatible avec cette instance de
de V8.

```js
console.log(v8.cachedDataVersionTag()); // 3947234607
// The value returned by v8.cachedDataVersionTag() is derived from the V8
// version, command-line flags, and detected CPU features. Test that the value
// does indeed update when flags are toggled.
v8.setFlagsFromString('--allow_natives_syntax');
console.log(v8.cachedDataVersionTag()); // 183726201
```

### <DataTag tag="M" /> `v8.getHeapCodeStatistics()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v12.8.0"]}}} />

* Returns: [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Obtenez des statistiques sur le code et ses métadonnées dans le tas, voir l'API V8
API [`GetHeapCodeAndMetadataStatistics`][]. Renvoie un objet avec les
propriétés suivantes :

* `code_and_metadata_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `bytecode_and_metadata_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `external_script_source_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `cpu_profiler_metadata_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)



```js
{
  code_and_metadata_size: 212208,
  bytecode_and_metadata_size: 161368,
  external_script_source_size: 1410794,
  cpu_profiler_metadata_size: 0,
}
```

### <DataTag tag="M" /> `v8.getHeapSnapshot()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v11.13.0"]}}} />

* Returns: [`stream.Readable`](/api/stream#streamreadable) A Readable Stream containing the V8 heap snapshot

Génère un instantané du tas V8 actuel et retourne un flux lisible
qui peut être utilisé pour lire la représentation sérialisée JSON.
Ce format de flux JSON est destiné à être utilisé avec des outils tels que
Chrome DevTools. Le schéma JSON est non documenté et spécifique au moteur
moteur V8. Par conséquent, le schéma peut changer d'une version de V8 à l'autre.

La création d'un instantané du tas nécessite une mémoire correspondant à environ deux fois la taille du tas au moment de la création de l'instantané.
tas au moment de la création de l'instantané. Cela entraîne le risque que des destructeurs d'OOM
de mettre fin au processus.

La génération d'un instantané est une opération synchrone qui bloque la boucle d'événement
pour une durée qui dépend de la taille du tas.

```js
// Print heap snapshot to the console
const v8 = require('node:v8');
const stream = v8.getHeapSnapshot();
stream.pipe(process.stdout);
```

### <DataTag tag="M" /> `v8.getHeapSpaceStatistics()`

<Metadata version="v18.8.0" data={{"changes":[{"version":"v7.5.0","pr-url":"https://github.com/nodejs/node/pull/10186","description":"Support values exceeding the 32-bit unsigned integer range."}],"update":{"type":"added","version":["v6.0.0"]}}} />

* Returns: Object\[]

Renvoie des statistiques sur les espaces du tas V8, c'est-à-dire les segments qui composent le
le tas V8. Ni l'ordre des espaces de tas, ni la disponibilité d'un espace de tas ne peuvent être garantis car les statistiques sont fournies par le serveur V8.
d'un espace de tas ne peut être garantie, car les statistiques sont fournies par le système V8.
[`GetHeapSpaceStatistics`][] et peuvent changer d'une version de V8 à l'autre.
suivante.

La valeur retournée est un tableau d'objets contenant les propriétés suivantes :

* `space_name` [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
* `space_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `space_used_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `space_available_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `physical_space_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

```json
[
  {
    "space_name": "new_space",
    "space_size": 2063872,
    "space_used_size": 951112,
    "space_available_size": 80824,
    "physical_space_size": 2063872
  },
  {
    "space_name": "old_space",
    "space_size": 3090560,
    "space_used_size": 2493792,
    "space_available_size": 0,
    "physical_space_size": 3090560
  },
  {
    "space_name": "code_space",
    "space_size": 1260160,
    "space_used_size": 644256,
    "space_available_size": 960,
    "physical_space_size": 1260160
  },
  {
    "space_name": "map_space",
    "space_size": 1094160,
    "space_used_size": 201608,
    "space_available_size": 0,
    "physical_space_size": 1094160
  },
  {
    "space_name": "large_object_space",
    "space_size": 0,
    "space_used_size": 0,
    "space_available_size": 1490980608,
    "physical_space_size": 0
  }
]
```

### <DataTag tag="M" /> `v8.getHeapStatistics()`

<Metadata version="v18.8.0" data={{"changes":[{"version":"v7.5.0","pr-url":"https://github.com/nodejs/node/pull/10186","description":"Support values exceeding the 32-bit unsigned integer range."},{"version":"v7.2.0","pr-url":"https://github.com/nodejs/node/pull/8610","description":"Added `malloced_memory`, `peak_malloced_memory`, and `does_zap_garbage`."}],"update":{"type":"added","version":["v1.0.0"]}}} />

* Returns: [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Renvoie un objet avec les propriétés suivantes :

* `total_heap_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `total_heap_size_executable` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `total_physical_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `total_available_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `used_heap_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `heap_size_limit` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `malloced_memory` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `peak_malloced_memory` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `does_zap_garbage` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `number_of_native_contexts` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `number_of_detached_contexts` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `total_global_handles_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `used_global_handles_size` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `external_memory` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`does_zap_garbage` est un booléen 0/1, qui signifie que l'option `--zap_code_space` est activée.
`--zap_code_space` est activée ou non. Cela permet à V8 d'écraser le tas
avec un motif de bits. L'empreinte du RSS (taille de l'ensemble des résidents) devient plus grande
parce qu'il touche continuellement toutes les pages du tas et cela les rend moins susceptibles
d'être échangées par le système d'exploitation.

`number_of_native_contexts` La valeur de native\_context est le nombre des
contextes de haut niveau actuellement actifs. L'augmentation de ce nombre dans le temps indique
une fuite de mémoire.

`number_of_detached_contexts` La valeur de detached_context correspond au nombre
de contextes qui ont été détachés et qui n'ont pas encore été ramassés. Ce nombre
étant non nul indique une fuite de mémoire potentielle.

`total_global_handles_size` La valeur de total\_global\_handles\_size correspond à la
taille totale de la mémoire des poignées globales de V8.

`used_global_handles_size` La valeur de used\_global\_handles\_size correspond à la
taille de la mémoire utilisée des poignées globales de V8.

`external_memory` La valeur de external\_memory est la taille de la mémoire des tampons
et des chaînes de caractères externes.



```js
{
  total_heap_size: 7326976,
  total_heap_size_executable: 4194304,
  total_physical_size: 7326976,
  total_available_size: 1152656,
  used_heap_size: 3476208,
  heap_size_limit: 1535115264,
  malloced_memory: 16384,
  peak_malloced_memory: 1127496,
  does_zap_garbage: 0,
  number_of_native_contexts: 1,
  number_of_detached_contexts: 0,
  total_global_handles_size: 8192,
  used_global_handles_size: 3296,
  external_memory: 318824
}
```

### <DataTag tag="M" /> `v8.setFlagsFromString(flags)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v1.0.0"]}}} />

* `flags` [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

La méthode `v8.setFlagsFromString()` peut être utilisée pour définir de façon programmatique
les drapeaux de la ligne de commande V8. Cette méthode doit être utilisée avec précaution. La modification des paramètres
après le démarrage de la VM peut entraîner un comportement imprévisible, notamment des
imprévisible, y compris des plantages et des pertes de données, ou tout simplement ne rien faire.

Les options V8 disponibles pour une version de Node.js peuvent être déterminées en exécutant
`node --v8-options`.

Usage:

```js
// Print GC events to stdout for one minute.
const v8 = require('node:v8');
v8.setFlagsFromString('--trace_gc');
setTimeout(() => { v8.setFlagsFromString('--notrace_gc'); }, 60e3);
```

### <DataTag tag="M" /> `v8.stopCoverage()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v15.1.0","v14.18.0","v12.22.0"]}}} />

La méthode `v8.stopCoverage()` permet à l'utilisateur d'arrêter la collection de couverture
de couverture lancée par [`NODE_V8_COVERAGE`][], afin que V8 puisse libérer les enregistrements de comptage
et optimiser le code. Cette méthode peut être utilisée en conjonction avec
[v8.takeCoverage()`][] si l'utilisateur souhaite collecter la couverture à la demande.

### <DataTag tag="M" /> `v8.takeCoverage()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v15.1.0","v14.18.0","v12.22.0"]}}} />

La méthode `v8.takeCoverage()` permet à l'utilisateur d'écrire sur le disque la couverture commencée par
[`NODE_V8_COVERAGE`][] sur le disque à la demande. Cette méthode peut être invoquée plusieurs
fois pendant la durée de vie du processus. A chaque fois, le compteur d'exécution sera
d'exécution sera réinitialisé et un nouveau rapport de couverture sera écrit dans le répertoire indiqué
par [`NODE_V8_COVERAGE`][].

Lorsque le processus est sur le point de se terminer, une dernière couverture sera encore écrite sur
disque sauf si [`v8.stopCoverage()`][] est invoqué avant que le processus ne se termine.

### <DataTag tag="M" /> `v8.writeHeapSnapshot([filename])`

<Metadata version="v18.8.0" data={{"changes":[{"version":"v18.0.0","pr-url":"https://github.com/nodejs/node/pull/41373","description":"An exception will now be thrown if the file could not be written."},{"version":"v18.0.0","pr-url":"https://github.com/nodejs/node/pull/42577","description":"Make the returned error codes consistent across all platforms."}],"update":{"type":"added","version":["v11.13.0"]}}} />

* `filename` [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) The file path where the V8 heap snapshot is to be
  saved. If not specified, a file name with the pattern
  `'Heap-$yyyymmdd-$hhmmss-$pid-${thread_id}.heapsnapshot'` will be
  generated, where `pid` will be the PID of the Node.js process,
  `{thread_id}` will be `0` when `writeHeapSnapshot()` is called from
  the main Node.js thread or the id of a worker thread.
* Returns: [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) The filename where the snapshot was saved.

Génère un instantané du tas V8 actuel et l'écrit dans un fichier JSON.
dans un fichier JSON. Ce fichier est destiné à être utilisé avec des outils tels que Chrome
DevTools. Le schéma JSON est non documenté et spécifique au moteur V8.
et peut changer d'une version de V8 à l'autre.

Un instantané de tas est spécifique à un seul isolat V8. Lorsque vous utilisez
l'utilisation de [worker threads][], un instantané du tas généré par le thread principal ne contiendra
ne contiendra aucune information sur les workers, et vice versa.

La création d'un instantané du tas nécessite une mémoire d'environ deux fois la taille du tas au moment de la création de l'instantané.
tas au moment de la création de l'instantané. Cela entraîne le risque que les OOM killers
de mettre fin au processus.

La génération d'un instantané est une opération synchrone qui bloque la boucle d'événement
pour une durée qui dépend de la taille du tas.

```js
const { writeHeapSnapshot } = require('node:v8');
const {
  Worker,
  isMainThread,
  parentPort
} = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);

  worker.once('message', (filename) => {
    console.log(`worker heapdump: $filename`);
    // Now get a heapdump for the main thread.
    console.log(`main thread heapdump: ${writeHeapSnapshot()}`);
  });

  // Tell the worker to create a heapdump.
  worker.postMessage('heapdump');
} else {
  parentPort.once('message', (message) => {
    if (message === 'heapdump') {
      // Generate a heapdump for the worker
      // and return the filename to the parent.
      parentPort.postMessage(writeHeapSnapshot());
    }
  });
}
```

### API de sérialisation

L'API de sérialisation fournit des moyens de sérialiser les valeurs JavaScript d'une façon
compatible avec l'[algorithme de clonage structuré HTML][].

Le format est rétrocompatible (c'est-à-dire que le stockage sur disque est sûr).
Des valeurs JavaScript égales peuvent donner lieu à une sortie sérialisée différente.

#### <DataTag tag="M" /> `v8.serialize(value)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

* `value` [`any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
* Returns: [`Buffer`](/api/buffer#buffer)

Utilise un [`DefaultSerializer`][] pour sérialiser `valeur` dans un tampon.

L'erreur [`ERR_BUFFER_TOO_LARGE`][] sera levée lorsque l'on essaiera de
sérialiser un objet énorme qui nécessite un tampon
plus grand que [`buffer.constants.MAX_LENGTH`][].

#### <DataTag tag="M" /> `v8.deserialize(buffer)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

* `buffer` [`Buffer`](/api/buffer#buffer) | [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) A buffer returned by [`serialize()`][].

Utilise un [`DefaultDeserializer`][] avec des options par défaut pour lire une valeur JS
à partir d'un tampon.

#### <DataTag tag="C" /> `v8.Serializer`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

##### <DataTag tag="M" /> `new Serializer()`

Creates a new `Serializer` object.

##### <DataTag tag="M" /> `serializer.writeHeader()`

Writes out a header, which includes the serialization format version.

##### <DataTag tag="M" /> `serializer.writeValue(value)`

* `value` [`any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

Sérialise une valeur JavaScript et ajoute la représentation sérialisée à la mémoire tampon interne.
tampon interne.

Une erreur est générée si `value` ne peut pas être sérialisée.

##### <DataTag tag="M" /> `serializer.releaseBuffer()`

* Returns: [`Buffer`](/api/buffer#buffer)

Renvoie le tampon interne stocké. Ce sérialiseur ne doit pas être utilisé une fois que
le tampon est libéré. L'appel de cette méthode entraîne un comportement non défini
si une écriture précédente a échoué.

##### <DataTag tag="M" /> `serializer.transferArrayBuffer(id, arrayBuffer)`

* `id` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) A 32-bit unsigned integer.
* `arrayBuffer` [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) An `ArrayBuffer` instance.

Marque un `ArrayBuffer` comme ayant son contenu transféré hors bande.
Passez le `ArrayBuffer` correspondant dans le contexte de désérialisation à
[`deserializer.transferArrayBuffer()`][].

##### <DataTag tag="M" /> `serializer.writeUint32(value)`

* `value` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Écriture d'un entier non signé 32 bits brut.
À utiliser dans un [`serializer._writeHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `serializer.writeUint64(hi, lo)`

* `hi` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* `lo` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Écriture d'un entier non signé 64 bits brut, divisé en parties 32 bits haute et basse.
À utiliser dans un [`serializer._writeHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `serializer.writeDouble(value)`

* `value` [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Ecrit une valeur JS `number`.
À utiliser dans un [`serializer._writeHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `serializer.writeRawBytes(buffer)`

* `buffer` [`Buffer`](/api/buffer#buffer) | [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)

Écrire des octets bruts dans le tampon interne du sérialiseur. Le désérialiseur
devra trouver un moyen de calculer la longueur du tampon.
À utiliser dans un [`serializer._writeHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `serializer._writeHostObject(object)`

* `object` [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

Cette méthode est appelée pour écrire un objet hôte, c'est-à-dire un objet créé par des liaisons C++ natives.
par des liaisons C++ natives. Si la sérialisation de l'objet n'est pas possible, une exception
exception appropriée doit être levée.

Cette méthode n'est pas présente sur la classe `Serializer` elle-même mais peut être fournie
par les sous-classes.

##### <DataTag tag="M" /> `serializer._getDataCloneError(message)`

* `message` [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Cette méthode est appelée pour générer des objets d'erreur qui seront lancés lorsqu'un objet
objet ne peut pas être cloné.

Cette méthode utilise par défaut le constructeur [`Error`][] et peut être surchargée sur les
sous-classes.

##### <DataTag tag="M" /> `serializer._getSharedArrayBufferId(sharedArrayBuffer)`

* `sharedArrayBuffer` [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)

Cette méthode est appelée lorsque le sérialiseur va sérialiser un objet
objet `SharedArrayBuffer`. Elle doit renvoyer un identifiant entier 32 bits non signé pour
l'objet, en utilisant le même ID si ce `SharedArrayBuffer` a déjà été sérialisé.
sérialisé. Lors de la désérialisation, cet ID sera transmis à
[`deserializer.transferArrayBuffer()`][].

Si l'objet ne peut pas être sérialisé, une exception doit être levée.

Cette méthode n'est pas présente sur la classe `Serializer` elle-même mais peut être fournie
par les sous-classes.

##### <DataTag tag="M" /> `serializer._setTreatArrayBufferViewsAsHostObjects(flag)`

* `flag` [`boolean`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **Default:** `false`

Indiquez s'il faut traiter les objets `TypedArray` et `DataView` comme des
comme des objets hôtes, c'est-à-dire les transmettre à [`serializer._writeHostObject()`][].

#### <DataTag tag="C" /> `v8.Deserializer`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

##### <DataTag tag="M" /> `new Deserializer(buffer)`

* `buffer` [`Buffer`](/api/buffer#buffer) | [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) A buffer returned by
  [`serializer.releaseBuffer()`][].

Crée un nouvel objet `Deserializer`

##### <DataTag tag="M" /> `deserializer.readHeader()`

Lit et valide un en-tête (y compris la version du format).
Peut, par exemple, rejeter un format de fil invalide ou non pris en charge. Dans ce cas,
une `Erreur` est lancée.

##### <DataTag tag="M" /> `deserializer.readValue()`

Désérialise une valeur JavaScript du tampon et la renvoie.

##### <DataTag tag="M" /> `deserializer.transferArrayBuffer(id, arrayBuffer)`

* `id` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) A 32-bit unsigned integer.
* `arrayBuffer` [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) An `ArrayBuffer` instance.

Marque un `ArrayBuffer` comme ayant son contenu transféré hors bande.
Passez le `ArrayBuffer` correspondant dans le contexte de sérialisation à
[`serializer.transferArrayBuffer()`][] (ou renvoyer le `id` à partir de
[`serializer._getSharedArrayBufferId()`][] dans le cas de `SharedArrayBuffer`s).

##### <DataTag tag="M" /> `deserializer.getWireFormatVersion()`

* Returns: [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Lit la version du format filaire sous-jacent. Probablement utile surtout pour
code hérité qui lit les anciennes versions du format filaire. Ne doit pas être appelé avant
`.readHeader()`.

##### <DataTag tag="M" /> `deserializer.readUint32()`

* Returns: [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Lit un entier non signé 32 bits brut et le renvoie.
À utiliser à l'intérieur d'un [`deserializer._readHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `deserializer.readUint64()`

* Returns: integer\[]

Lit un entier non signé brut de 64 bits et le renvoie sous la forme d'un tableau `[hi, lo]``.
avec deux entrées d'entiers non signés de 32 bits.
À utiliser à l'intérieur d'un [`deserializer._readHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `deserializer.readDouble()`

* Returns: [`number`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

Lit une valeur JS `number`.
À utiliser à l'intérieur d'un [`deserializer._readHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `deserializer.readRawBytes(length)`

* `length` [`integer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
* Returns: [`Buffer`](/api/buffer#buffer)

Lit des octets bruts à partir du tampon interne du désérialiseur. Le paramètre "length" doit
doit correspondre à la longueur du tampon qui a été transmis à
[`serializer.writeRawBytes()`][].
À utiliser à l'intérieur d'un [`deserializer._readHostObject()`][] personnalisé.

##### <DataTag tag="M" /> `deserializer._readHostObject()`

Cette méthode est appelée pour lire une sorte d'objet hôte, c'est-à-dire un objet qui est
créé par des liaisons C++ natives. S'il n'est pas possible de désérialiser les données,
une exception appropriée doit être levée.

Cette méthode n'est pas présente sur la classe `Deserializer` elle-même mais peut être
fournie par les sous-classes.

#### <DataTag tag="C" /> `v8.DefaultSerializer`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

Une sous-classe de [`Serializer`][] qui sérialise les objets `TypedArray`
(en particulier [`Buffer`][]) et des objets `DataView` en tant qu'objets hôtes, et ne
stocke uniquement la partie de leur `ArrayBuffer` sous-jacent à laquelle ils font référence.

#### <DataTag tag="C" /> `v8.DefaultDeserializer`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v8.0.0"]}}} />

Une sous-classe de [`Deserializer`][] correspondant au format écrit par
[`DefaultSerializer`][].

### Crochets de promesse

L'interface `promiseHooks` peut être utilisée pour suivre les événements du cycle de vie des promesses.
Pour suivre _toute_ l'activité asynchrone, voir [`async_hooks`][] qui utilise en interne ce module pour produire des événements de cycle de vie de promesses en plus des événements pour d'autres types de promesses.
module pour produire des événements de cycle de vie des promesses en plus des événements pour d'autres
ressources asynchrones. Pour la gestion du contexte de la demande, voir [`AsyncLocalStorage`][].

```mjs
import { promiseHooks } from 'node:v8';

// Les promesses produisent quatre événements de cycle de vie :

// L'événement `init` représente la création d'une promesse. Cela peut être une
// une création directe comme avec `new Promise(...)` ou une continuation comme
// comme `then()` ou `catch()`. Cela se produit également lorsqu'une fonction asynchrone est
// appelée ou fait un `await`. Si une promesse de continuation est créée, le
// `parent` sera la promesse dont elle est la continuation.
function init(promise, parent) {
  console.log('a promise was created', { promise, parent });
}

// L'événement `settled` se produit lorsqu'une promesse reçoit une résolution ou
// une valeur de rejet. Cela peut se produire de manière synchrone, par exemple en utilisant
// `Promise.resolve()` sur une entrée non promise.
function settled(promise) {
  console.log('a promise resolved or rejected', { promise });
}

// L'événement `before` s'exécute immédiatement avant qu'un gestionnaire `then()` ou `catch()` ne soit exécuté ou qu'un `await` ne reprenne l'exécution.
// s'exécute ou un `await` reprend l'exécution.
function before(promise) {
  console.log('a promise is about to call a then handler', { promise });
}

// L'événement `after` s'exécute immédiatement après l'exécution d'un gestionnaire `then()` ou lorsque
// un `await` commence après la reprise d'un autre.
function after(promise) {
  console.log('a promise is done calling a then handler', { promise });
}

// Les crochets du cycle de vie peuvent être lancés et arrêtés individuellement.
const stopWatchingInits = promiseHooks.onInit(init);
const stopWatchingSettleds = promiseHooks.onSettled(settled);
const stopWatchingBefores = promiseHooks.onBefore(before);
const stopWatchingAfters = promiseHooks.onAfter(after);

// Ou ils peuvent être démarrés et arrêtés en groupe
const stopHookSet = promiseHooks.createHook({
  init,
  settled,
  before,
  after
});

// Pour arrêter un crochet, appelez la fonction retournée lors de sa création.
stopWatchingInits();
stopWatchingSettleds();
stopWatchingBefores();
stopWatchingAfters();
stopHookSet();
```

#### <DataTag tag="M" /> `promiseHooks.onInit(init)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v17.1.0","v16.14.0"]}}} />

* `init` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`init` callback][] to call when a promise is created.
* Returns: [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Call to stop the hook.

**Le hook `init` doit être une fonction ordinaire. Fournir une fonction asynchrone sera
jettera car elle produirait une boucle de micro-tâche infinie.**

```mjs
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onInit((promise, parent) => {});
```

```cjs
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onInit((promise, parent) => {});
```

#### <DataTag tag="M" /> `promiseHooks.onSettled(settled)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v17.1.0","v16.14.0"]}}} />

* `settled` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`settled` callback][] to call when a promise
  is resolved or rejected.
* Returns: [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Call to stop the hook.

**Le hook `settled` doit être une fonction simple. Fournir une fonction asynchrone sera
jettera car elle produirait une boucle de micro-tâche infinie.**

```mjs
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onSettled((promise) => {});
```

```cjs
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onSettled((promise) => {});
```

#### <DataTag tag="M" /> `promiseHooks.onBefore(before)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v17.1.0","v16.14.0"]}}} />

* `before` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`before` callback][] to call before a promise
  continuation executes.
* Returns: [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Call to stop the hook.

**Le crochet `before` doit être une fonction ordinaire. Fournir une fonction asynchrone sera
jettera car elle produirait une boucle de micro-tâche infinie.**

```mjs
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onBefore((promise) => {});
```

```cjs
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onBefore((promise) => {});
```

#### <DataTag tag="M" /> `promiseHooks.onAfter(after)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v17.1.0","v16.14.0"]}}} />

* `after` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`after` callback][] to call after a promise
  continuation executes.
* Returns: [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Call to stop the hook.

**Le crochet `after` doit être une fonction ordinaire. Fournir une fonction asynchrone sera
jettera car elle produirait une boucle de micro-tâche infinie.**

```mjs
import { promiseHooks } from 'node:v8';

const stop = promiseHooks.onAfter((promise) => {});
```

```cjs
const { promiseHooks } = require('node:v8');

const stop = promiseHooks.onAfter((promise) => {});
```

#### <DataTag tag="M" /> `promiseHooks.createHook(callbacks)`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v17.1.0","v16.14.0"]}}} />

* `callbacks` [`Object`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) The [Hook Callbacks][] to register
  * `init` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`init` callback][].
  * `before` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`before` callback][].
  * `after` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`after` callback][].
  * `settled` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) The [`settled` callback][].
* Returns: [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Used for disabling hooks

**Les callbacks du hook doivent être des fonctions simples. Fournir des fonctions asynchrones sera
car cela produirait une boucle de micro-tâche infinie.**

Enregistre les fonctions à appeler pour les différents événements de vie de chaque promesse.

Les callbacks `init()`/`before()`/`after()`/`settled()` sont appelés lors des événements
événements respectifs au cours de la vie d'une promesse.

Tous les callbacks sont optionnels. Par exemple, si seule la création d'une promesse doit
être suivie, alors seul le callback `init` doit être passé. Le site
spécificités de toutes les fonctions qui peuvent être passées aux `callbacks` se trouvent dans la section
section [Hook Callbacks][].

```mjs
import { promiseHooks } from 'node:v8';

const stopAll = promiseHooks.createHook({
  init(promise, parent) {}
});
```

```cjs
const { promiseHooks } = require('node:v8');

const stopAll = promiseHooks.createHook({
  init(promise, parent) {}
});
```

#### Rappels de crochets

Les événements clés de la vie d'une promesse ont été classés en quatre catégories :
la création d'une promesse, avant/après l'appel d'un gestionnaire de continuation ou autour de
un await, et lorsque la promesse est résolue ou rejetée.

Bien que ces crochets soient similaires à ceux de [`async_hooks`][], il manque un crochet de type
`destroy`. D'autres types de ressources asynchrones représentent typiquement les sockets ou les
des descripteurs de fichiers qui ont un état "fermé" distinct pour exprimer l'événement du cycle de vie `destroy`.
tandis que les promesses restent utilisables tant que le code peut encore les atteindre.
les atteindre. Le suivi de la collecte des déchets est utilisé pour que les promesses s'intègrent dans l'événement
modèle d'événement `async_hooks`, mais ce suivi est très coûteux et il se peut qu'elles ne soient même pas collectées.
et elles ne seront peut-être même jamais collectées.

Parce que les promesses sont des ressources asynchrones dont le cycle de vie est suivi
via le mécanisme des crochets de promesses, les fonctions `init()`, `before()`, `after()`, et
callbacks `settled()` ne doivent pas être des fonctions asynchrones car elles créent plus de
promesses, ce qui produirait une boucle infinie.

Bien que cette API soit utilisée pour alimenter les événements de promesses dans [`async_hooks`][], l'ordre entre les deux n'est pas défini.
l'ordre entre les deux est indéfini. Les deux API sont multi-tenant
et peuvent donc produire des événements dans n'importe quel ordre les uns par rapport aux autres.

##### <DataTag tag="M" /> `init(promise, parent)`

* `promise` [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) The promise being created.
* `parent` [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) The promise continued from, if applicable.

Appelé lorsqu'une promesse est construite. Cela ne signifie pas que les événements correspondants
que les événements "avant" et "après" correspondants se produiront, mais seulement que la possibilité existe. Cela se produira
Cela se produira si une promesse est créée sans jamais obtenir de continuation.

##### <DataTag tag="M" /> `before(promise)`

* `promise` [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Appelé avant l'exécution de la suite d'une promesse. Cela peut être sous la forme de
`then()`, `catch()`, ou `finally()` handlers ou d'un rappel `await`.

Le callback `before` sera appelé de 0 à N fois. Le rappel `before`
sera typiquement appelé 0 fois si aucune continuation n'a jamais été faite pour la
promesse. Le rappel `before` peut être appelé de nombreuses fois dans le cas où
de nombreuses continuations ont été faites à partir de la même promesse.

##### <DataTag tag="M" /> `after(promise)`

* `promise` [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Appelé immédiatement après l'exécution d'une continuation de promesse. Cela peut être après un gestionnaire
`then()`, `catch()`, ou `finally()` ou avant un `await` après un autre `await`.
après un autre `await`.

##### <DataTag tag="M" /> `settled(promise)`

* `promise` [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Appelé lorsque la promesse reçoit une valeur de résolution ou de rejet. Cela peut
se produire de manière synchrone dans le cas de `Promise.resolve()` ou `Promise.reject()`.

### Startup Snapshot API

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v18.6.0"]}}} />

<Metadata version="v18.8.0" data={{"stability":{"level":1,"text":" - Experimental"}}} />

L'interface `v8.startupSnapshot' peut être utilisée pour ajouter des crochets de
désérialisation pour des instantanés de démarrage personnalisés. Actuellement, les instantanés de démarrage
peuvent seulement être construits dans le binaire de Node.js à partir de la source.

```console
$ cd /path/to/node
$ ./configure --node-snapshot-main=entry.js
$ make node
# This binary contains the result of the execution of entry.js
$ out/Release/node
```

Dans l'exemple ci-dessus, `entry.js` peut utiliser les méthodes de l'interface `v8.startupSnapshot`
pour spécifier comment sauvegarder les informations des objets personnalisés dans le snapshot
pendant la sérialisation et comment utiliser ces informations pour synchroniser ces
objets pendant la désérialisation de l'instantané. Par exemple, si le fichier `entry.js`
contient le script suivant :

```cjs
'use strict';

const fs = require('fs');
const zlib = require('zlib');
const path = require('path');
const assert = require('assert');

const {
  isBuildingSnapshot,
  addSerializeCallback,
  addDeserializeCallback,
  setDeserializeMainFunction
} = require('v8').startupSnapshot;

const filePath = path.resolve(__dirname, '../x1024.txt');
const storage = {};

assert(isBuildingSnapshot());

addSerializeCallback(({ filePath }) => {
  storage[filePath] = zlib.gzipSync(fs.readFileSync(filePath));
}, { filePath });

addDeserializeCallback(({ filePath }) => {
  storage[filePath] = zlib.gunzipSync(storage[filePath]);
}, { filePath });

setDeserializeMainFunction(({ filePath }) => {
  console.log(storage[filePath].toString());
}, { filePath });
```

Le binaire résultant imprimera simplement les données désérialisées à partir du snapshot
lors du démarrage :

```console
$ out/Release/node
# Prints content of ./test/fixtures/x1024.txt
```

Actuellement, l'API n'est disponible que pour une instance de Node.js lancée à partir de l'instantané par défaut, c'est-à-dire l'application désérialisée à partir d'une zone utilisateur.
snapshot par défaut, c'est-à-dire que l'application désérialisée à partir d'un snapshot de l'utilisateur
snapshot ne peut plus utiliser ces APIs.

#### <DataTag tag="M" /> `v8.startupSnapshot.addSerializeCallback(callback[, data])`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v18.6.0"]}}} />

* `callback` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback to be invoked before serialization.
* `data` [`any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Optional data that will be passed to the `callback` when it
  gets called.

Ajoutez un callback qui sera appelé lorsque l'instance de Node.js est sur le point de
d'être sérialisée en un instantané et de sortir. Ceci peut être utilisé pour libérer
ressources qui ne doivent pas ou ne peuvent pas être sérialisées ou pour convertir les données utilisateur
en une forme plus adaptée à la sérialisation.

#### <DataTag tag="M" /> `v8.startupSnapshot.addDeserializeCallback(callback[, data])`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v18.6.0"]}}} />

* `callback` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback to be invoked after the snapshot is
  deserialized.
* `data` [`any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Optional data that will be passed to the `callback` when it
  gets called.

Ajoutez un callback qui sera appelé lorsque l'instance de Node.js est désérialisée
à partir d'un instantané. La `callback` et les `data` (si elles sont fournies) seront
sérialisées dans le snapshot, elles peuvent être utilisées pour réinitialiser l'état
de l'application ou pour réacquérir les ressources dont l'application a besoin
lorsque l'application est redémarrée à partir de l'instantané.

#### <DataTag tag="M" /> `v8.startupSnapshot.setDeserializeMainFunction(callback[, data])`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v18.6.0"]}}} />

* `callback` [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) Callback to be invoked as the entry point after the
  snapshot is deserialized.
* `data` [`any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Optional data that will be passed to the `callback` when it
  gets called.

Ceci définit le point d'entrée de l'application Node.js lorsqu'elle est désérialisée
à partir d'un instantané. Ceci ne peut être appelé qu'une seule fois dans le script de construction de l'instantané.
de l'instantané. Si elle est appelée, l'application désérialisée n'a plus besoin d'un script de point d'entrée supplémentaire pour démarrer.
script de point d'entrée supplémentaire pour démarrer et invoquera simplement la callback avec
données désérialisées (si elles sont fournies), sinon un script de point d'entrée doit toujours
d'entrée doit toujours être fourni à l'application désérialisée.

#### <DataTag tag="M" /> `v8.startupSnapshot.isBuildingSnapshot()`

<Metadata version="v18.8.0" data={{"update":{"type":"added","version":["v18.6.0"]}}} />

* Returns: [`boolean`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

Renvoie true si l'instance Node.js est exécutée pour construire un instantané.

[HTML structured clone algorithm]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
[Hook Callbacks]: #hook-callbacks
[V8]: https://developers.google.com/v8/
[`AsyncLocalStorage`]: async_context.md#class-asynclocalstorage
[`Buffer`]: /api/v18/buffer
[`DefaultDeserializer`]: #class-v8defaultdeserializer
[`DefaultSerializer`]: #class-v8defaultserializer
[`Deserializer`]: #class-v8deserializer
[`ERR_BUFFER_TOO_LARGE`]: /api/v18/errors#err_buffer_too_large
[`Error`]: /api/v18/errors#class-error
[`GetHeapCodeAndMetadataStatistics`]: https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#a6079122af17612ef54ef3348ce170866
[`GetHeapSpaceStatistics`]: https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#ac673576f24fdc7a33378f8f57e1d13a4
[`NODE_V8_COVERAGE`]: /api/v18/cli#node_v8_coveragedir
[`Serializer`]: #class-v8serializer
[`after` callback]: #afterpromise
[`async_hooks`]: async_hooks.md
[`before` callback]: #beforepromise
[`buffer.constants.MAX_LENGTH`]: /api/v18/buffer#bufferconstantsmax_length
[`deserializer._readHostObject()`]: #deserializer_readhostobject
[`deserializer.transferArrayBuffer()`]: #deserializertransferarraybufferid-arraybuffer
[`init` callback]: #initpromise-parent
[`serialize()`]: #v8serializevalue
[`serializer._getSharedArrayBufferId()`]: #serializer_getsharedarraybufferidsharedarraybuffer
[`serializer._writeHostObject()`]: #serializer_writehostobjectobject
[`serializer.releaseBuffer()`]: #serializerreleasebuffer
[`serializer.transferArrayBuffer()`]: #serializertransferarraybufferid-arraybuffer
[`serializer.writeRawBytes()`]: #serializerwriterawbytesbuffer
[`settled` callback]: #settledpromise
[`v8.stopCoverage()`]: #v8stopcoverage
[`v8.takeCoverage()`]: #v8takecoverage
[`vm.Script`]: /api/v18/vm#new-vmscriptcode-options
[worker threads]: worker_threads.md
